library(dplyr)
library(utils)
library(binaryLogic)

frac.to.bin = function(x, bits=10) {
  bin = ""
  for(i in 1:bits) {
    # Multiply decimal by 2
    x2 = x*2
    
    # Integer part
    int = floor(x2)
    
    # Decimal part
    d = x2-int
    
    # Add integer part to binary representation
    bin = paste(bin, int, sep='')
    
    # Continue disregarding integer part
    x = d
  }
  
  return(bin)
}
bin.carry <- function(x, pos = nchar(x)) {
  # Performs addition with one on binary number string.
  # Important: On strings like 111, returns the same string
  
  if(!grepl("0", x)) {
    return(x)
  } else if(pos == 1) {
    if(substr(x, pos, pos) == "0") {
      substr(x, pos, pos) <- "1"
      return(x)
    } else {
      return(x)
    }
  } else {
    if(substr(x, pos, pos) == "0") {
      substr(x, pos, pos) = "1"
      return(x)
    } else {
      substr(x, pos, pos) = "0"
      return(carry(x, pos-1))
    }
  }
}
round.bin = function(x, bits) {
  # Rounds a binary number string to specified number of bits
  
  pre = substr(x, 1, bits)
  post = substr(x, bits+1, bits+1)
  if(post == "0") {
    rounded = pre
  } else {
    if(!grepl("0", pre)) {
      return(pre)
    } else {
      return(bin.carry(pre))
    }
  }
  return(rounded)
}


# Algorithm ---------------------------------------------------------------
P.X <- c(1/2, 1/4, 1/8, 1/8) # a)
# P.X <- c(1/3, 1/3, 1/3)      # b)
# P.X <- c(0.2, 0.199, 0.199, 0.199, 0.199, 0.004)
# P.X <- c(0.3, 0.3, 0.2, 0.1, 0.1)

if(sum(P.X) != 1) { stop("Ey, sum is not equal to one") }

surprisal <- P.X %>%
  sapply(log2) %>%
  sapply(function(x) {return(-x) })

surprisal.ceil <- surprisal %>%
  sapply(ceiling)

F.i <- 1:length(P.X) %>%
  sapply(function(i) {
    if(i == 1) 0 else sum(P.X[1:(i-1)]) %>%
      return
  })

F.i.bin = F.i %>%
  sapply(frac.to.bin)

F.i.bin.rounded = 1:length(F.i.bin) %>%
  sapply(function(i) {
    bits = surprisal.ceil[i]
    return(round.bin(F.i.bin[i], surprisal.ceil[i]))
  })

data.frame(i = 1:length(P.X), P.X, surprisal, surprisal.ceil, F.i, F.i.bin, F.i.bin.rounded)
